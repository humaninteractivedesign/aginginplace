unit TestMQTTHeaders;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, Classes, Types, MQTTHeaders, SysUtils;

type
  // Test methods for class TMQTTFixedHeader

  TestTMQTTFixedHeader = class(TTestCase)
  strict private
    FMQTTFixedHeader: TMQTTFixedHeader;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestToByte;
    procedure TestToByteStr;
    procedure TestMessageTypes;
  end;

  // Test methods for RL Methods

  TestUtilityMethods = class(TTestCase)
  strict private

  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestToRLToBytes;
    procedure TestUTF8EncodeToBytes;
    procedure TestIntToMSBLSB;
  end;

  // Test methods for class TMQTTConnectVarHeader

  TestTMQTTConnectVarHeader = class(TTestCase)
  strict private
    FMQTTConnectVarHeader: TMQTTConnectVarHeader;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestToBytes;
    procedure TestVersionStrings;
    procedure TestKeepAliveOnCreation;
  end;
  // Test methods for class TMQTTPublishVarHeader

  TestTMQTTPublishVarHeader = class(TTestCase)
  strict private
    FMQTTPublishVarHeader: TMQTTPublishVarHeader;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestToBytes;
  end;
  // Test methods for class TMQTTSubscribeVarHeader

  TestTMQTTSubscribeVarHeader = class(TTestCase)
  strict private
    FMQTTSubscribeVarHeader: TMQTTSubscribeVarHeader;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestToBytes;
  end;
  // Test methods for class TMQTTUnsubscribeVarHeader

  TestTMQTTUnsubscribeVarHeader = class(TTestCase)
  strict private
    FMQTTUnsubscribeVarHeader: TMQTTUnsubscribeVarHeader;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestToBytes;
  end;
  // Test methods for class TMQTTPayload

  TestTMQTTPayload = class(TTestCase)
  strict private
    FMQTTPayload: TMQTTPayload;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestToBytes;
  end;
  // Test methods for class TMQTTMessage

  TestTMQTTMessage = class(TTestCase)
  strict private
    FMQTTMessage: TMQTTMessage;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestToBytes;
    procedure TestToBytesPublish;
  end;

implementation

function IntToBin ( value: LongInt; digits: integer ): string;
begin
    result := StringOfChar ( '0', digits ) ;
    while value > 0 do begin
      if ( value and 1 ) = 1 then
        result [ digits ] := '1';
      dec ( digits ) ;
      value := value shr 1;
    end;
end;

procedure TestTMQTTConnectVarHeader.SetUp;
begin
  FMQTTConnectVarHeader := TMQTTConnectVarHeader.Create;
end;

procedure TestTMQTTConnectVarHeader.TearDown;
begin
  FMQTTConnectVarHeader.Free;
  FMQTTConnectVarHeader := nil;
end;

procedure TestTMQTTConnectVarHeader.TestKeepAliveOnCreation;
var
  ConnectVar: TMQTTConnectVarHeader;
begin
  ConnectVar := TMQTTConnectVarHeader.Create(10);
  Assert( ConnectVar.KeepAlive = 10, 'Keep Alive assigned' );
  ConnectVar.Free;
end;

procedure TestTMQTTConnectVarHeader.TestToBytes;
var
  ReturnValue: TBytes;
  i: integer;
begin
  FMQTTConnectVarHeader.KeepAlive := 10;
  FMQTTConnectVarHeader.CleanStart := 1;
  FMQTTConnectVarHeader.WillFlag := 1;
  FMQTTConnectVarHeader.QoSLevel := 0;
  FMQTTConnectVarHeader.Retain := 0;
  //FMQTTConnectVarHeader.
  ReturnValue := FMQTTConnectVarHeader.ToBytes;
  Assert( Length(ReturnValue) = 12 , 'Length of Connect Variable Header' );
  Assert( ReturnValue[0] = 0, 'Length of version string' );
  Assert( ReturnValue[1] = Length(FMQTTConnectVarHeader.PROTOCOL_ID), 'Length of version string' );
  for I := 1 to Length(FMQTTConnectVarHeader.PROTOCOL_ID) do
  begin
    Assert( Chr(ReturnValue[i + 1]) = FMQTTConnectVarHeader.PROTOCOL_ID[i], 'Version String, expected: ' + FMQTTConnectVarHeader.PROTOCOL_ID[i] + ' got:' + Chr(ReturnValue[1 + i]) );
  end;
  // Todo: Finish the rest of this.
end;

procedure TestTMQTTConnectVarHeader.TestVersionStrings;
begin
  Assert( FMQTTConnectVarHeader.PROTOCOL_ID = 'MQIsdp', 'Version String = MQIsdp' );
  Assert( FMQTTConnectVarHeader.PROTOCOL_VER = 3, 'Version 3 of the Protocol' );
end;

procedure TestTMQTTPublishVarHeader.SetUp;
begin
  FMQTTPublishVarHeader := TMQTTPublishVarHeader.Create;
end;

procedure TestTMQTTPublishVarHeader.TearDown;
begin
  FMQTTPublishVarHeader.Free;
  FMQTTPublishVarHeader := nil;
end;

procedure TestTMQTTPublishVarHeader.TestToBytes;
var
  ReturnValue: TBytes;
begin
  ReturnValue := FMQTTPublishVarHeader.ToBytes;
  // TODO: Validate method results
end;

procedure TestTMQTTSubscribeVarHeader.SetUp;
begin
  FMQTTSubscribeVarHeader := TMQTTSubscribeVarHeader.Create;
end;

procedure TestTMQTTSubscribeVarHeader.TearDown;
begin
  FMQTTSubscribeVarHeader.Free;
  FMQTTSubscribeVarHeader := nil;
end;

procedure TestTMQTTSubscribeVarHeader.TestToBytes;
var
  ReturnValue: TBytes;
begin
  ReturnValue := FMQTTSubscribeVarHeader.ToBytes;
  // TODO: Validate method results
end;

procedure TestTMQTTUnsubscribeVarHeader.SetUp;
begin
  FMQTTUnsubscribeVarHeader := TMQTTUnsubscribeVarHeader.Create;
end;

procedure TestTMQTTUnsubscribeVarHeader.TearDown;
begin
  FMQTTUnsubscribeVarHeader.Free;
  FMQTTUnsubscribeVarHeader := nil;
end;

procedure TestTMQTTUnsubscribeVarHeader.TestToBytes;
var
  ReturnValue: TBytes;
begin
  ReturnValue := FMQTTUnsubscribeVarHeader.ToBytes;
  // TODO: Validate method results
end;

procedure TestTMQTTPayload.SetUp;
begin
  FMQTTPayload := TMQTTPayload.Create;
end;

procedure TestTMQTTPayload.TearDown;
begin
  FMQTTPayload.Free;
  FMQTTPayload := nil;
end;

procedure TestTMQTTPayload.TestToBytes;
var
  ReturnValue: TBytes;
begin
  FMQTTPayload.Contents.Add('test');
  ReturnValue := FMQTTPayload.ToBytes;
  Assert( ReturnValue[0] = 0, 'Length Bytes' );
  Assert( ReturnValue[1] = 4, 'Length Bytes' );
  Assert( Chr(ReturnValue[2]) = 't', 'test String' );
  Assert( Chr(ReturnValue[3]) = 'e', 'test String' );
  Assert( Chr(ReturnValue[4]) = 's', 'test String' );
  Assert( Chr(ReturnValue[5]) = 't', 'test String' );
  FMQTTPayload.Contents.Add('again');
  ReturnValue := FMQTTPayload.ToBytes;
  Assert( ReturnValue[6] = 0, 'Length Bytes' );
  Assert( ReturnValue[7] = 5, 'Length Bytes, Actual Value' + IntToStr(ReturnValue[7]) );
  Assert( Chr(ReturnValue[8]) = 'a', 'again String' );
  Assert( Chr(ReturnValue[9]) = 'g', 'again String' );
  Assert( Chr(ReturnValue[10]) = 'a', 'again String' );
  Assert( Chr(ReturnValue[11]) = 'i', 'again String' );
  Assert( Chr(ReturnValue[12]) = 'n', 'again String' );
end;

procedure TestTMQTTMessage.SetUp;
begin
  FMQTTMessage := TMQTTMessage.Create;
end;

procedure TestTMQTTMessage.TearDown;
begin
  FMQTTMessage.Free;
  FMQTTMessage := nil;
end;

procedure TestTMQTTMessage.TestToBytes;
var
  ReturnValue: TBytes;
  FH: TMQTTFixedHeader;
  VH: TMQTTConnectVarHeader;
  PL: TMQTTPayload;
begin
  FH.MessageType := Ord(TMQTTMessageType.CONNECT);
  FMQTTMessage.FixedHeader := FH;
  VH := TMQTTConnectVarHeader.Create(10);
  VH.CleanStart := 1;
  VH.WillFlag := 1;
  VH.QoSLevel := 1;
  FMQTTMessage.VariableHeader := VH;
  PL := TMQTTPayload.Create;
  PL.Contents.Add('/test');
  PL.Contents.Add('broker died!');
  FMQTTMessage.Payload := PL;

  ReturnValue := FMQTTMessage.ToBytes;
  // TODO: Validate the whole message end to end.
  Assert( ReturnValue[0] = 16, 'Connect Flag' );
  Assert( ReturnValue[1] = 33, 'Remaining Length Bytes' + IntToStr(ReturnValue[1]) );   //12 + 20
  Assert( ReturnValue[2] = 0, 'VString L' );
  Assert( ReturnValue[3] = Length(TMQTTConnectVarHeader.PROTOCOL_ID), 'Variable Length' );
  //Assert( Chr(ReturnValue[2]) = 't', 'test String' );
  //Assert( Chr(ReturnValue[3]) = 'e', 'test String' );
  //Assert( Chr(ReturnValue[4]) = 's', 'test String' );
  //Assert( Chr(ReturnValue[5]) = 't', 'test String' );
end;

procedure TestTMQTTMessage.TestToBytesPublish;
var
  ReturnValue: TBytes;
  FH: TMQTTFixedHeader;
  VH: TMQTTPublishVarHeader;
  PL: TMQTTPayload;
begin
  FH.MessageType := Ord(TMQTTMessageType.PUBLISH);
  FMQTTMessage.FixedHeader := FH;
  VH := TMQTTPublishVarHeader.Create(0);
  VH.Topic := '/dev/test';
  FMQTTMessage.VariableHeader := VH;
  PL := TMQTTPayload.Create;
  PL.Contents.Add('this is a test!');
  FMQTTMessage.Payload := PL;

  ReturnValue := FMQTTMessage.ToBytes;
  // TODO: Validate the whole message end to end.
  Assert( ReturnValue[0] = 48, 'Publish Flag' );
  Assert( ReturnValue[1] = 28, 'Remaining Length Bytes: ' + IntToStr(ReturnValue[1]) );   //12 + 20
  Assert( ReturnValue[2] = 0, 'String Low:' );
  Assert( ReturnValue[3] = 9, 'String High:' + IntToStr(ReturnValue[3]));
  Assert( ReturnValue[13] = 0, 'String Low:' );
  Assert( ReturnValue[14] = 15, 'String High:' + IntToStr(ReturnValue[14]));
  Assert( Chr(ReturnValue[15]) = 't', 'test String' );
  Assert( Chr(ReturnValue[16]) = 'h', 'test String' );
  Assert( Chr(ReturnValue[17]) = 'i', 'test String' );
  Assert( Chr(ReturnValue[18]) = 's', 'test String' );
end;

{ TestTMQTTFixedHeader }

procedure TestTMQTTFixedHeader.SetUp;
begin
  inherited;
  FMQTTFixedHeader.MessageType := Ord(TMQTTMessageType.CONNECT);
  FMQTTFixedHeader.Retain := 0;
  FMQTTFixedHeader.QoSLevel := 0;
  FMQTTFixedHeader.Duplicate := 0;
end;

procedure TestTMQTTFixedHeader.TearDown;
begin
  inherited;

end;

procedure TestTMQTTFixedHeader.TestMessageTypes;
begin
  FMQTTFixedHeader.MessageType := Ord(TMQTTMessageType.CONNECT);
  Assert( FMQTTFixedHeader.Flags  = 16, 'Fixed Header - Connect' );
  FMQTTFixedHeader.MessageType := Ord(TMQTTMessageType.CONNACK);
  Assert( FMQTTFixedHeader.Flags  = 32, 'Fixed Header - ConAck' );
  FMQTTFixedHeader.MessageType := Ord(TMQTTMessageType.PUBLISH);
  Assert( FMQTTFixedHeader.Flags  = 48, 'Fixed Header - Publish' );
  FMQTTFixedHeader.MessageType := Ord(TMQTTMessageType.PUBACK);
  Assert( FMQTTFixedHeader.Flags  = 64, 'Fixed Header - PubAck' );
  FMQTTFixedHeader.MessageType := Ord(TMQTTMessageType.PUBREC);
  Assert( FMQTTFixedHeader.Flags  = 80, 'Fixed Header - PubRec' );
  FMQTTFixedHeader.MessageType := Ord(TMQTTMessageType.PUBREL);
  Assert( FMQTTFixedHeader.Flags  = 96, 'Fixed Header - PubRel' );
  FMQTTFixedHeader.MessageType := Ord(TMQTTMessageType.PUBCOMP);
  Assert( FMQTTFixedHeader.Flags  = 112, 'Fixed Header - PubComp' );
  FMQTTFixedHeader.MessageType := Ord(TMQTTMessageType.SUBSCRIBE);
  Assert( FMQTTFixedHeader.Flags  = 128, 'Fixed Header - Subscribe' );
  FMQTTFixedHeader.MessageType := Ord(TMQTTMessageType.SUBACK);
  Assert( FMQTTFixedHeader.Flags  = 144, 'Fixed Header - Sub Ack' );
  FMQTTFixedHeader.MessageType := Ord(TMQTTMessageType.UNSUBSCRIBE);
  Assert( FMQTTFixedHeader.Flags  = 160, 'Fixed Header - Unsubscribe' );
  FMQTTFixedHeader.MessageType := Ord(TMQTTMessageType.UNSUBACK);
  Assert( FMQTTFixedHeader.Flags  = 176, 'Fixed Header - Unsubscribe Ack' );
  FMQTTFixedHeader.MessageType := Ord(TMQTTMessageType.PINGREQ);
  Assert( FMQTTFixedHeader.Flags  = 192, 'Fixed Header - Ping Req' );
  FMQTTFixedHeader.MessageType := Ord(TMQTTMessageType.PINGRESP);
  Assert( FMQTTFixedHeader.Flags  = 208, 'Fixed Header - Ping Resp' );
  FMQTTFixedHeader.MessageType := Ord(TMQTTMessageType.DISCONNECT);
  Assert( FMQTTFixedHeader.Flags  = 224, 'Fixed Header - Disconnect' );
end;

procedure TestTMQTTFixedHeader.TestToByte;
var
  byteValue: Word;
begin
  byteValue := FMQTTFixedHeader.Flags;
  Assert( byteValue  = 16, 'Fixed Header Flags' );
end;

procedure TestTMQTTFixedHeader.TestToByteStr;
var
  byteValue: Word;
  str: string;
begin
  byteValue := FMQTTFixedHeader.Flags;
  str := IntToBin(byteValue, 8);
  Assert( str  = '00010000', 'Fixed Header Flags' );
end;

{ TestRLMethods }

procedure TestUtilityMethods.SetUp;
begin
  inherited;

end;


procedure TestUtilityMethods.TearDown;
begin
  inherited;

end;

procedure TestUtilityMethods.TestIntToMSBLSB;
var
  LengthBytes: TBytes;
begin
  LengthBytes := TMQTTUtilities.IntToMSBLSB(4);
  Assert( LengthBytes[0] = 0, 'Zero' );
  Assert( LengthBytes[1] = 4, 'Size' );
  LengthBytes := TMQTTUtilities.IntToMSBLSB(8);
  Assert( LengthBytes[0] = 0, 'Zero' );
  Assert( LengthBytes[1] = 8, 'Size' );
  LengthBytes := TMQTTUtilities.IntToMSBLSB(20);
  Assert( LengthBytes[0] = 0, 'Zero' );
  Assert( LengthBytes[1] = 20, 'Size' );
end;

procedure TestUtilityMethods.TestToRLToBytes;
var
  RLBytes: TBytes;
begin
  RLBytes := TMQTTUtilities.RLIntToBytes(0);
  Assert( Length(RLBytes)  = 1, 'Correct number of Bytes' );
  Assert( RLBytes[0] = 0, 'Correct Value in byte 0' );
  RLBytes := TMQTTUtilities.RLIntToBytes(126);
  Assert( Length(RLBytes)  = 1, 'Correct number of Bytes' );
  Assert( RLBytes[0] = 126, 'Correct Value in byte 0' );
  RLBytes := TMQTTUtilities.RLIntToBytes(128);
  Assert( Length(RLBytes)  = 2, 'Correct number of Bytes' );
  Assert( RLBytes[0] = 128, 'Correct Value in byte 0' );
  Assert( RLBytes[1] = 1, 'Correct Value in byte 1' );
  RLBytes := TMQTTUtilities.RLIntToBytes(16383);
  Assert( Length(RLBytes)  = 2, 'Correct number of Bytes' );
  Assert( RLBytes[0] = 255, 'Correct Value in byte 0' );
  Assert( RLBytes[1] = 127, 'Correct Value in byte 1' );
  RLBytes := TMQTTUtilities.RLIntToBytes(16384);
  Assert( Length(RLBytes)  = 3, 'Correct number of Bytes' );
  Assert( RLBytes[0] = 128, 'Correct Value in byte 0' );
  Assert( RLBytes[1] = 128, 'Correct Value in byte 1' );
  Assert( RLBytes[2] = 1, 'Correct Value in byte 2' );
  RLBytes := TMQTTUtilities.RLIntToBytes(268435455);
  Assert( Length(RLBytes)  = 4, 'Correct number of Bytes' );
  Assert( RLBytes[0] = 255, 'Correct Value in byte 0' );
  Assert( RLBytes[1] = 255, 'Correct Value in byte 1' );
  Assert( RLBytes[2] = 255, 'Correct Value in byte 2' );
  Assert( RLBytes[3] = 127, 'Correct Value in byte 3' );
end;

procedure TestUtilityMethods.TestUTF8EncodeToBytes;
var
  str: TBytes;
  testStr: string;
  testStringSets: Array of string;
  i: integer;
begin
  SetLength(testStringSets, 3);
  testStringSets[0] := 'test';
  testStringSets[1] := 'test';
  testStringSets[2] := 'test';

  for testStr in testStringSets do
  begin
    str := TMQTTUtilities.UTF8EncodeToBytes(testStr);
    Assert( Length(str) = Length(testStr) + 2, 'Length of UTF8 Bytes' );
    Assert( str[0] = 0, 'Correct Length Value in byte 0' );
    Assert( str[1] = Length(testStr), 'Correct Length Value in byte 1' );
    for I := 2 to Length(str) do
    begin
      Assert( testStr[i - 1] = Chr(str[i]), 'Correct String, Expected: ' + testStr[i - 1] + ' Got: ' + Chr(str[i]));
    end;
  end;
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTMQTTFixedHeader.Suite);
  RegisterTest(TestUtilityMethods.Suite);
  RegisterTest(TestTMQTTConnectVarHeader.Suite);
  RegisterTest(TestTMQTTPublishVarHeader.Suite);
  RegisterTest(TestTMQTTSubscribeVarHeader.Suite);
  RegisterTest(TestTMQTTUnsubscribeVarHeader.Suite);
  RegisterTest(TestTMQTTPayload.Suite);
  RegisterTest(TestTMQTTMessage.Suite);
end.

